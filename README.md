# Thirty For Thirty

Thirty sites in which I recreate interactions/animations/effects I think are cool or simply challenging or interesting. It's a way for me to learn things I don't otherwise have the opportunity to explore.

## Today's site: xtian.design

This site does a few things I thought would be fun to figure out.

* Animate distortion effects on an image
* Break headlines in half
* Seamlessly reset scrolling once you reach the bottom
* Animate a fancy little loading circle

The xtian site uses several javascript libraries including [Pixi.js](http://pixijs.io/), [GSAP](https://greensock.com/gsap), [ScrollMagic](http://scrollmagic.io/docs/index.html), [jQuery](https://jquery.com/), and one or more jQuery plugins — I believe for taking over scrolling and handling scroll momentum.

I created a web page that does some of these same things: [thirty-sites-1](https://akiryk.github.io/thirty-sites-1/index.html).

## How to distort an image

The effect on xtian.design is achieved by animating a displacement filter, in this case, an image of clouds generated by Photoshop or something similar. I won't explain how to use Pixi here, but the basic steps are as follows:

1. Load a main image (e.g. the skateboarder) and a clouds image into Pixi sprites
2. Create a new displacement filter using the clouds image.
3. Set the strength of the displacement filter using x and y scales.
4. Enable a Pixi game loop to animate the clouds image. In this case, I'm having it rotate endlessly, which creates the initial distortion animation you see when the site loads.

[Learn more about Pixi filters](http://pixijs.io/pixi-filters/tools/demo/).

## How to reduce the distortion effect on scroll

This is handled by ScrollMagic and GSAP (TweenLite). As the page scrolls away from the intro section, the x and y scales of the distortion effect are tweened to zero.

```JavaScript
    // Get a reference to the Pixi displacement filter's scale
    const scaleObj = this.displacementFilter.scale;

    // Create a GSAP tween that uses the filter scale
    // In this case, I'm animating from the default scale of 150 or so down to 0.
    const distortionTween = TweenLite.to(scaleObj, .85, {x: 0, y: 0});

    // Create a ScrollMagic Scene and set the distortionTween based on whatever trigger you want.
    new ScrollMagic.Scene({ // etc. etc
```

## How to break headlines in half

Create three copies of the same headline, `class="headline-top"`, `class="headline-bottom"` and `class="headline-guide` and put them in container with `position: relative`.

For headlines top and bottom:
```CSS
    position: absolute;
    height: 56%;
    width: 100%;
    overflow: hidden;
```

Put the text for headline-bottom in a span element. Then style that span so it's offset.
```CSS
    display: block;
    position: absolute;
    top: -100%;
    left: 0;
    width: 100%;
    height: 100%;
```

For the guide headline, set `visibility: hidden` This way, you won't see the guide but it will occupy space and prevent the absolutely positioned half-headlines from collapsing.

Alternatively, use clip-path to make the two headlines display top and bottom. I used this method for the End headline.

```CSS
    .end-headline--top {
      clip-path: inset(0 0 50% 0);
    }

    .end-headline--bottom {
      clip-path: inset(50% 0 0 0);
    }
```

Animating the halves is simply a matter of creating ScrollMagic scenes that tween rotation, x, and y properties.

## Create a fancy little loader.

Check out [my pen here](https://codepen.io/akiryk/pen/KQPYBW).

## How to scroll seamlessly

I didn't really figure this out except to see that it requires taking control of scrolling away from the user. I tried to do it without, but the native scroll really doesn't like being jerked around like that.

Two of the steps are:

1. Create a clone of the intro headline and place it at the end of the page content.
2. Track the y position of the two headlines relative to the page, and when the clone version reaches the place where the original version started use scrollTo() and go back to the top. Endless scrolling.

Here's some psuedo-ish code that starts to do that.

```JavaScript
    const startY = getYPosition(originalHeadline);

    /**
     * @description Get the y position of an element
     * @param {element}
     * @return {number} yPos
     */
    getYPosition(el) {
      let yPos = 0;
      while(el) {
        yPos += (el.offsetTop - el.scrollTop + el.clientTop);
        el = el.offsetParent;
      }
      return yPos;
    }

    const scene = new ScrollMagic.Scene().addTo(controller)

    // On scene update, check location of the two headlines and scroll direction.
    scene.on('update', function(event) {
        const dir = controller.info('scrollDirection');
        const cloneY = clone.getBoundingClientRect().top;
        const introY = intro.getBoundingClientRect().top;
        if (cloneY <= startY){
          const diff = startY - cloneY;
          resetTitleStyles();
          window.scroll(0,diff);
        }
        if (dir === 'REVERSE' && ceiling(introY) >= startY) {
          resetTitleStyles();
          window.scroll(0, cloneY - startY);
        }
      });
```
